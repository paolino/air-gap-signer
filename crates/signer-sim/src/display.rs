use minifb::Window;
use signer_core::display::DisplayLine;
use signer_hal::HalError;

const WIDTH: usize = 640;
const HEIGHT: usize = 480;
const CHAR_W: usize = 8;
const LINE_HEIGHT: usize = 10; // 8px glyph + 2px gap
const COLS: usize = WIDTH / CHAR_W; // 80
const VISIBLE_LINES: usize = HEIGHT / LINE_HEIGHT; // 48

/// Minimal 8x8 bitmap font covering ASCII 32..127.
/// Each character is 8 bytes, one byte per row, MSB-left.
#[rustfmt::skip]
static FONT_8X8: [u8; 96 * 8] = [
    // 32 ' '
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // 33 '!'
    0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x00,
    // 34 '"'
    0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,
    // 35 '#'
    0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00,
    // 36 '$'
    0x18,0x7E,0xC0,0x7C,0x06,0xFC,0x18,0x00,
    // 37 '%'
    0x00,0xC6,0xCC,0x18,0x30,0x66,0xC6,0x00,
    // 38 '&'
    0x38,0x6C,0x38,0x76,0xDC,0xCC,0x76,0x00,
    // 39 '''
    0x18,0x18,0x30,0x00,0x00,0x00,0x00,0x00,
    // 40 '('
    0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00,
    // 41 ')'
    0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00,
    // 42 '*'
    0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,
    // 43 '+'
    0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,
    // 44 ','
    0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30,
    // 45 '-'
    0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,
    // 46 '.'
    0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,
    // 47 '/'
    0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,
    // 48 '0'
    0x7C,0xC6,0xCE,0xDE,0xF6,0xE6,0x7C,0x00,
    // 49 '1'
    0x18,0x38,0x78,0x18,0x18,0x18,0x7E,0x00,
    // 50 '2'
    0x7C,0xC6,0x06,0x1C,0x30,0x60,0xFE,0x00,
    // 51 '3'
    0x7C,0xC6,0x06,0x3C,0x06,0xC6,0x7C,0x00,
    // 52 '4'
    0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x00,
    // 53 '5'
    0xFE,0xC0,0xFC,0x06,0x06,0xC6,0x7C,0x00,
    // 54 '6'
    0x38,0x60,0xC0,0xFC,0xC6,0xC6,0x7C,0x00,
    // 55 '7'
    0xFE,0xC6,0x0C,0x18,0x30,0x30,0x30,0x00,
    // 56 '8'
    0x7C,0xC6,0xC6,0x7C,0xC6,0xC6,0x7C,0x00,
    // 57 '9'
    0x7C,0xC6,0xC6,0x7E,0x06,0x0C,0x78,0x00,
    // 58 ':'
    0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,
    // 59 ';'
    0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30,
    // 60 '<'
    0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00,
    // 61 '='
    0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00,
    // 62 '>'
    0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00,
    // 63 '?'
    0x7C,0xC6,0x0C,0x18,0x18,0x00,0x18,0x00,
    // 64 '@'
    0x7C,0xC6,0xDE,0xDE,0xDC,0xC0,0x7C,0x00,
    // 65 'A'
    0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0x00,
    // 66 'B'
    0xFC,0xC6,0xC6,0xFC,0xC6,0xC6,0xFC,0x00,
    // 67 'C'
    0x3C,0x66,0xC0,0xC0,0xC0,0x66,0x3C,0x00,
    // 68 'D'
    0xF8,0xCC,0xC6,0xC6,0xC6,0xCC,0xF8,0x00,
    // 69 'E'
    0xFE,0xC0,0xC0,0xFC,0xC0,0xC0,0xFE,0x00,
    // 70 'F'
    0xFE,0xC0,0xC0,0xFC,0xC0,0xC0,0xC0,0x00,
    // 71 'G'
    0x3C,0x66,0xC0,0xCE,0xC6,0x66,0x3E,0x00,
    // 72 'H'
    0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00,
    // 73 'I'
    0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,
    // 74 'J'
    0x1E,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00,
    // 75 'K'
    0xC6,0xCC,0xD8,0xF0,0xD8,0xCC,0xC6,0x00,
    // 76 'L'
    0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xFE,0x00,
    // 77 'M'
    0xC6,0xEE,0xFE,0xD6,0xC6,0xC6,0xC6,0x00,
    // 78 'N'
    0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00,
    // 79 'O'
    0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,
    // 80 'P'
    0xFC,0xC6,0xC6,0xFC,0xC0,0xC0,0xC0,0x00,
    // 81 'Q'
    0x7C,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x06,
    // 82 'R'
    0xFC,0xC6,0xC6,0xFC,0xD8,0xCC,0xC6,0x00,
    // 83 'S'
    0x7C,0xC6,0xC0,0x7C,0x06,0xC6,0x7C,0x00,
    // 84 'T'
    0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00,
    // 85 'U'
    0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,
    // 86 'V'
    0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x10,0x00,
    // 87 'W'
    0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0x00,
    // 88 'X'
    0xC6,0xC6,0x6C,0x38,0x6C,0xC6,0xC6,0x00,
    // 89 'Y'
    0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00,
    // 90 'Z'
    0xFE,0x06,0x0C,0x18,0x30,0x60,0xFE,0x00,
    // 91 '['
    0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,
    // 92 '\'
    0x80,0xC0,0x60,0x30,0x18,0x0C,0x06,0x00,
    // 93 ']'
    0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,
    // 94 '^'
    0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,
    // 95 '_'
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,
    // 96 '`'
    0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,
    // 97 'a'
    0x00,0x00,0x7C,0x06,0x7E,0xC6,0x7E,0x00,
    // 98 'b'
    0xC0,0xC0,0xFC,0xC6,0xC6,0xC6,0xFC,0x00,
    // 99 'c'
    0x00,0x00,0x7C,0xC6,0xC0,0xC6,0x7C,0x00,
    // 100 'd'
    0x06,0x06,0x7E,0xC6,0xC6,0xC6,0x7E,0x00,
    // 101 'e'
    0x00,0x00,0x7C,0xC6,0xFE,0xC0,0x7C,0x00,
    // 102 'f'
    0x1C,0x36,0x30,0x78,0x30,0x30,0x30,0x00,
    // 103 'g'
    0x00,0x00,0x7E,0xC6,0xC6,0x7E,0x06,0x7C,
    // 104 'h'
    0xC0,0xC0,0xFC,0xC6,0xC6,0xC6,0xC6,0x00,
    // 105 'i'
    0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00,
    // 106 'j'
    0x06,0x00,0x06,0x06,0x06,0x06,0xC6,0x7C,
    // 107 'k'
    0xC0,0xC0,0xCC,0xD8,0xF0,0xD8,0xCC,0x00,
    // 108 'l'
    0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,
    // 109 'm'
    0x00,0x00,0xCC,0xFE,0xD6,0xC6,0xC6,0x00,
    // 110 'n'
    0x00,0x00,0xFC,0xC6,0xC6,0xC6,0xC6,0x00,
    // 111 'o'
    0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0x00,
    // 112 'p'
    0x00,0x00,0xFC,0xC6,0xC6,0xFC,0xC0,0xC0,
    // 113 'q'
    0x00,0x00,0x7E,0xC6,0xC6,0x7E,0x06,0x06,
    // 114 'r'
    0x00,0x00,0xDC,0xE6,0xC0,0xC0,0xC0,0x00,
    // 115 's'
    0x00,0x00,0x7E,0xC0,0x7C,0x06,0xFC,0x00,
    // 116 't'
    0x30,0x30,0x7C,0x30,0x30,0x36,0x1C,0x00,
    // 117 'u'
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0x7E,0x00,
    // 118 'v'
    0x00,0x00,0xC6,0xC6,0xC6,0x6C,0x38,0x00,
    // 119 'w'
    0x00,0x00,0xC6,0xC6,0xD6,0xFE,0x6C,0x00,
    // 120 'x'
    0x00,0x00,0xC6,0x6C,0x38,0x6C,0xC6,0x00,
    // 121 'y'
    0x00,0x00,0xC6,0xC6,0xC6,0x7E,0x06,0x7C,
    // 122 'z'
    0x00,0x00,0xFE,0x0C,0x38,0x60,0xFE,0x00,
    // 123 '{'
    0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00,
    // 124 '|'
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,
    // 125 '}'
    0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00,
    // 126 '~'
    0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,
    // 127 DEL (blank)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];

const FG: u32 = 0x00FF_FFFF; // white
const BG: u32 = 0x0010_1010; // near-black

pub struct SimDisplay {
    window: Window,
    buf: Vec<u32>,
}

impl SimDisplay {
    pub fn new() -> Result<Self, HalError> {
        let window = Window::new(
            "Air-Gap Signer Simulator",
            WIDTH,
            HEIGHT,
            minifb::WindowOptions::default(),
        )
        .map_err(|e| HalError::Display(e.to_string()))?;

        let buf = vec![BG; WIDTH * HEIGHT];
        Ok(Self { window, buf })
    }

    pub fn window_mut(&mut self) -> &mut Window {
        &mut self.window
    }

    fn draw_char(&mut self, ch: u8, col: usize, row: usize) {
        let idx = if (32..128).contains(&ch) {
            (ch - 32) as usize
        } else {
            // replacement: '?'
            (b'?' - 32) as usize
        };
        let glyph = &FONT_8X8[idx * 8..(idx + 1) * 8];
        let x0 = col * CHAR_W;
        let y0 = row * LINE_HEIGHT;
        for (dy, &row_bits) in glyph.iter().enumerate() {
            let y = y0 + dy;
            if y >= HEIGHT {
                break;
            }
            for dx in 0..CHAR_W {
                let x = x0 + dx;
                if x >= WIDTH {
                    break;
                }
                let pixel = if row_bits & (0x80 >> dx) != 0 { FG } else { BG };
                self.buf[y * WIDTH + x] = pixel;
            }
        }
    }

    fn draw_text(&mut self, text: &str, col: usize, row: usize) {
        for (i, ch) in text.bytes().enumerate() {
            if col + i >= COLS {
                break;
            }
            self.draw_char(ch, col + i, row);
        }
    }

    fn clear_buf(&mut self) {
        self.buf.fill(BG);
    }

    fn update(&mut self) -> Result<(), HalError> {
        self.window
            .update_with_buffer(&self.buf, WIDTH, HEIGHT)
            .map_err(|e| HalError::Display(e.to_string()))
    }
}

impl signer_hal::Display for SimDisplay {
    fn clear(&mut self) -> Result<(), HalError> {
        self.clear_buf();
        self.update()
    }

    fn show_message(&mut self, text: &str) -> Result<(), HalError> {
        self.clear_buf();
        // Center the message vertically and horizontally
        let row = VISIBLE_LINES / 2;
        let col = if text.len() < COLS {
            (COLS - text.len()) / 2
        } else {
            0
        };
        self.draw_text(text, col, row);
        self.update()
    }

    fn show_lines(&mut self, lines: &[DisplayLine], scroll_offset: usize) -> Result<(), HalError> {
        self.clear_buf();
        // Header
        let header = format!(
            " [{}/{}]  Enter=OK  Esc=Cancel  \u{2191}/\u{2193}=Scroll",
            scroll_offset + 1,
            lines.len().max(1),
        );
        self.draw_text(&header, 0, 0);
        // Separator line
        self.draw_text(&"\u{2500}".repeat(COLS), 0, 1);

        let content_start = 2;
        let content_lines = VISIBLE_LINES.saturating_sub(content_start);

        for (i, line) in lines
            .iter()
            .skip(scroll_offset)
            .take(content_lines)
            .enumerate()
        {
            let pad = "  ".repeat(line.indent);
            let text = match &line.key {
                Some(k) if line.value.is_empty() => format!("{pad}{k}:"),
                Some(k) => format!("{pad}{k}: {}", line.value),
                None => format!("{pad}{}", line.value),
            };
            self.draw_text(&text, 0, content_start + i);
        }

        self.update()
    }
}
