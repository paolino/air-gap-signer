{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Air-Gapped Transaction Signer","text":"<p>A blockchain-agnostic air-gapped signing device for Raspberry Pi (4 or Zero 2W).</p> <p>The device never touches a network. Transactions arrive on a USB stick, get displayed for human review, and are signed with keys held in a secure element that never exposes them.</p>"},{"location":"#how-it-works","title":"How it works","text":"<pre><code>sequenceDiagram\n    participant USB as USB Stick\n    participant Dev as Signer Device\n    participant User as Human\n\n    USB-&gt;&gt;Dev: Insert (payload.bin, interpreter.wasm, sign.cbor)\n    Dev-&gt;&gt;Dev: Run WASM interpret(payload) \u2192 JSON\n    Dev-&gt;&gt;User: Display transaction details on screen\n    User-&gt;&gt;Dev: CONFIRM / REJECT\n    Dev-&gt;&gt;Dev: Send hash to secure element \u2192 signature\n    Dev-&gt;&gt;USB: Write signed.bin\n    Dev-&gt;&gt;User: \"DONE \u2014 REMOVE USB\"</code></pre>"},{"location":"#key-properties","title":"Key properties","text":"<ul> <li>Blockchain-agnostic \u2014 the USB stick carries a WASM interpreter that knows   how to parse the specific transaction format. The device only knows how to   run WASM, render JSON, and sign bytes.</li> <li>Air-gapped \u2014 no networking hardware enabled. No WiFi, no Bluetooth,   no Ethernet. Only USB mass storage for data transfer.</li> <li>Secure element \u2014 private keys live in an ATECC608B chip connected via   I2C. The Pi never sees raw key material. The chip enforces PIN retry limits   in hardware (lockout after N failures), so a stolen SD card is worthless.</li> <li>Sandboxed interpreters \u2014 WASM modules run with zero host imports,   fuel-metered (10M ops), and memory-capped (16 MB).</li> <li>Minimal attack surface \u2014 Buildroot Linux with a stripped kernel,   read-only rootfs, our binary as PID 1.</li> </ul>"},{"location":"#project-status","title":"Project status","text":"<p>Currently in Phase 0 \u2014 foundation crate with signing spec types, WASM sandbox, Ed25519 crypto, and a trivial echo interpreter. See Phases for the roadmap.</p>"},{"location":"architecture/overview/","title":"Architecture Overview","text":""},{"location":"architecture/overview/#crate-structure","title":"Crate structure","text":"<pre><code>graph TD\n    SIM[signer-sim&lt;br/&gt;Desktop simulator] --&gt; HAL[signer-hal&lt;br/&gt;HW abstraction traits]\n    SIM --&gt; CORE[signer-core&lt;br/&gt;Pure logic]\n    CORE --&gt; WT[wasmtime]\n    CORE --&gt; CIB[ciborium]\n    HAL --&gt; SE[Secure Element&lt;br/&gt;SE050 via I2C]\n\n    BIN[signer-bin&lt;br/&gt;PID 1 binary]:::future --&gt; HAL\n    BIN --&gt; CORE\n    PI[signer-pi&lt;br/&gt;Pi HAL impl]:::future --&gt; HAL\n    PI --&gt; CORE\n\n    classDef future stroke-dasharray: 5 5</code></pre> Crate Status Purpose <code>signer-core</code> done Pure logic: spec types, WASM sandbox, display, hash extraction <code>signer-hal</code> done Trait definitions: <code>Display</code>, <code>Buttons</code>, <code>UsbMount</code>, <code>SecureElement</code> <code>signer-sim</code> done Desktop simulator: minifb window, keyboard, simulated SE with PIN + keystore <code>usb-pack</code> stub CLI tool to prepare USB stick contents <code>signer-pi</code> Phase 4 Raspberry Pi implementation: linuxfb, gpiod, mount, I2C SE050 <code>signer-bin</code> Phase 4 The PID 1 binary (state machine orchestrating everything)"},{"location":"architecture/overview/#device-flow","title":"Device flow","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; CheckProvisioned: Boot\n    CheckProvisioned --&gt; Setup: Not provisioned\n    CheckProvisioned --&gt; PinEntry: Already provisioned\n\n    state Setup {\n        [*] --&gt; SetPin: SET PIN + CONFIRM\n        SetPin --&gt; PrivateUSB: Insert private USB\n        PrivateUSB --&gt; Recovery: seed.bin found\n        PrivateUSB --&gt; Generate: seed.bin missing\n        Recovery --&gt; PublicUSB: Import key\n        Generate --&gt; PublicUSB: Generate key + write seed.bin\n        PublicUSB --&gt; [*]: Write pubkey.bin\n    }\n\n    Setup --&gt; PinEntry: Setup complete\n    PinEntry --&gt; Idle: PIN verified by secure element\n    Idle --&gt; Loading: USB inserted\n    Loading --&gt; Displaying: WASM interpret \u2192 JSON\n    Displaying --&gt; Signing: User confirms\n    Displaying --&gt; Idle: User rejects\n    Signing --&gt; Done: SE signs hash \u2192 write signed.bin\n    Done --&gt; Idle: USB removed</code></pre>"},{"location":"architecture/overview/#interpreters","title":"Interpreters","text":"<p>WASM modules are carried on the USB stick alongside the transaction payload. Each blockchain ecosystem ships its own interpreter:</p> Interpreter Status Format Output <code>echo-hex</code> done Any Hex dump (testing) <code>cardano-cbor</code> Phase 2 Cardano TX CBOR Structured JSON (inputs, outputs, fee, metadata) <code>bitcoin-psbt</code> future Bitcoin PSBT Structured JSON (inputs, outputs, fee) <p>Interpreters are compiled to <code>wasm32-unknown-unknown</code> and must export:</p> <ul> <li><code>alloc(size) \u2192 ptr</code> \u2014 bump allocator</li> <li><code>interpret(ptr, len) \u2192 ptr</code> \u2014 parse payload, return length-prefixed JSON</li> <li><code>assemble(payload_ptr, payload_len, sig_ptr, sig_len) \u2192 ptr</code> \u2014 (optional) combine payload + signature</li> </ul>"},{"location":"architecture/secure-element/","title":"Secure Element","text":""},{"location":"architecture/secure-element/#why","title":"Why","text":"<p>Private keys stored on an SD card (even encrypted) are vulnerable to offline brute-force. A 6-digit PIN has ~20 bits of entropy \u2014 a GPU rig cracks Argon2id-protected keys in hours.</p> <p>A hardware secure element solves this: the chip holds the private key internally and enforces PIN retry limits (e.g. lockout after 10 failures). A stolen SD card contains no secrets. During provisioning the seed is exported once to a private USB stick for offline backup \u2014 after that the key lives only inside the chip.</p>"},{"location":"architecture/secure-element/#hardware","title":"Hardware","text":"<p>NXP SE050C1HQ1 \u2014 EdgeLock SE050, HX2QFN20 package (3\u00d73 mm).</p> <ul> <li>I2C interface (SDA/SCL on Pi GPIO 2/3)</li> <li>Native Ed25519, secp256k1, and NIST P-256 support</li> <li>Hardware key generation and signing \u2014 private key never leaves the chip</li> <li>PIN retry policy enforced in hardware</li> <li>Secure key storage with multiple slots</li> <li>CC EAL6+ certified</li> </ul> <p>Why SE050 over ATECC608B</p> <p>The ATECC608B (~2 EUR) only supports ECDSA P-256 natively. Cardano and Bitcoin require Ed25519 / secp256k1, which would force the Pi to handle raw key material in RAM. The SE050 (~5-10 EUR) signs natively with these curves \u2014 the private key never reaches the Pi.</p>"},{"location":"architecture/secure-element/#breakout-board","title":"Breakout board","text":"<p>A custom 20\u00d720 mm breakout board connects the SE050 to the Pi via an 8-pin header. It includes decoupling caps, I2C pull-up resistors, and mounting holes.</p> <p></p> <p>Generate Gerber files with <code>just gerbers</code> (see <code>hardware/SE050_breakout/generate_gerbers.py</code> for the full specification in <code>hardware/SE050_breakout/generate_gerbers.prompt.md</code>).</p>"},{"location":"architecture/secure-element/#key-lifecycle","title":"Key lifecycle","text":"<pre><code>sequenceDiagram\n    participant User as Human\n    participant Pi as Raspberry Pi\n    participant SE as Secure Element\n\n    Note over Pi,SE: First boot (provisioning)\n    User-&gt;&gt;Pi: Set PIN + Confirm PIN (buttons)\n    Pi-&gt;&gt;SE: set_pin(hash)\n    Pi-&gt;&gt;SE: verify_pin(hash)\n    User-&gt;&gt;Pi: Insert private USB\n    alt seed.bin exists on USB (recovery)\n        Pi-&gt;&gt;SE: import_key(slot 0, seed)\n    else no seed on USB (fresh)\n        Pi-&gt;&gt;SE: generate_key(slot 0)\n        SE--&gt;&gt;Pi: public key\n        Pi-&gt;&gt;SE: export_seed(slot 0)\n        Pi-&gt;&gt;Pi: Write seed.bin to private USB\n    end\n    User-&gt;&gt;Pi: Remove private USB, insert public USB\n    Pi-&gt;&gt;Pi: Write pubkey.bin to public USB\n    User-&gt;&gt;Pi: Remove public USB \u2014 store private USB safely\n\n    Note over Pi,SE: Normal boot\n    User-&gt;&gt;Pi: Enter PIN (buttons, 4 digits)\n    Pi-&gt;&gt;SE: verify_pin(hash)\n    SE--&gt;&gt;Pi: OK (or error if wrong PIN)\n\n    Note over Pi,SE: Signing\n    Pi-&gt;&gt;Pi: Extract hash from payload (WASM + spec)\n    Pi-&gt;&gt;SE: sign(slot N, hash)\n    SE--&gt;&gt;SE: Sign internally\n    SE-&gt;&gt;Pi: Signature bytes\n    Pi-&gt;&gt;Pi: Write signature to USB</code></pre>"},{"location":"architecture/secure-element/#hal-trait","title":"HAL trait","text":"<pre><code>pub trait SecureElement {\n    /// Set the initial PIN during first-time setup.\n    fn set_pin(&amp;mut self, pin: &amp;[u8]) -&gt; Result&lt;(), HalError&gt;;\n\n    /// Verify the user PIN.\n    fn verify_pin(&amp;mut self, pin: &amp;[u8]) -&gt; Result&lt;(), HalError&gt;;\n\n    /// Check whether the device has been provisioned (PIN set, key generated).\n    fn is_provisioned(&amp;self) -&gt; bool;\n\n    /// Generate a keypair in the given slot. Returns the public key.\n    fn generate_key(&amp;mut self, slot: u8) -&gt; Result&lt;Vec&lt;u8&gt;, HalError&gt;;\n\n    /// Sign a hash using the key in the given slot.\n    /// Requires prior PIN verification in the same session.\n    fn sign(&amp;mut self, slot: u8, hash: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, HalError&gt;;\n\n    /// Read the public key from a slot.\n    fn public_key(&amp;self, slot: u8) -&gt; Result&lt;Vec&lt;u8&gt;, HalError&gt;;\n\n    /// Import an existing seed into a slot (recovery from backup).\n    fn import_key(&amp;mut self, slot: u8, seed: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, HalError&gt;;\n\n    /// Export the seed for backup during provisioning.\n    fn export_seed(&amp;self, slot: u8) -&gt; Result&lt;Vec&lt;u8&gt;, HalError&gt;;\n}\n</code></pre>"},{"location":"architecture/secure-element/#threat-model","title":"Threat model","text":"Threat Mitigation Stolen SD card No secrets on SD \u2014 SE holds all keys Lost/destroyed device Seed backup on private USB allows full recovery on a new device Stolen device (powered off) PIN required on every boot, SE locks after N failures Stolen device (powered on) Physical access to buttons required to confirm each signing Stolen private USB Contains raw seed \u2014 store offline in a safe, treat like a hardware wallet recovery phrase Side-channel on Pi Pi never handles raw key material \u2014 SE050 signs internally Glitch attack on SE SE050 CC EAL6+ certified, tamper-resistant USB-borne malware WASM sandbox: no host imports, fuel-limited, memory-capped"},{"location":"architecture/signing-spec/","title":"Signing Spec","text":"<p>The <code>sign.cbor</code> file on the USB stick tells the device how to sign the transaction.</p>"},{"location":"architecture/signing-spec/#structure","title":"Structure","text":"<pre><code>struct SigningSpec {\n    label: String,          // Human-readable label (\"Cardano Transaction\")\n    signable: Signable,     // What bytes to sign\n    algorithm: SignAlgorithm, // Which signing algorithm\n    key_slot: u8,           // Secure element key slot (0\u201315)\n    output: OutputSpec,     // How to produce the output\n}\n</code></pre> <p>The <code>key_slot</code> identifies which key slot in the secure element to use for signing. The device sends the hash to the secure element, which signs internally and returns the signature. The private key never leaves the chip.</p>"},{"location":"architecture/signing-spec/#signable","title":"Signable","text":"<p>Determines which bytes from the payload get signed:</p> Variant Description <code>Whole</code> Sign the entire payload as-is <code>Range { offset, length }</code> Sign a byte range within the payload <code>HashThenSign { hash, source }</code> Hash first (Blake2b-256, SHA-256, or SHA3-256), then sign the hash <p><code>HashThenSign</code> is the most common mode \u2014 Cardano signs the Blake2b-256 hash of the transaction body, not the raw bytes.</p>"},{"location":"architecture/signing-spec/#algorithms","title":"Algorithms","text":"Algorithm Key size Signature size Use case Ed25519 32 bytes 64 bytes Cardano, Solana Secp256k1 ECDSA 32 bytes 64-72 bytes Bitcoin, Ethereum Secp256k1 Schnorr 32 bytes 64 bytes Bitcoin Taproot"},{"location":"architecture/signing-spec/#output-modes","title":"Output modes","text":"Mode Behavior <code>SignatureOnly</code> Write raw signature bytes to <code>signed.bin</code> <code>AppendToPayload</code> Concatenate payload + signature <code>WasmAssemble</code> Call the interpreter's <code>assemble()</code> function to produce chain-specific format"},{"location":"architecture/signing-spec/#encoding","title":"Encoding","text":"<p>The spec is CBOR-encoded (via <code>ciborium</code> / serde) for compact binary representation. The <code>usb-pack</code> CLI generates it from command-line flags.</p>"},{"location":"architecture/usb-protocol/","title":"USB Stick Protocol","text":"<p>The USB stick is the only data channel between the outside world and the signing device. It carries three files:</p> File Purpose <code>payload.bin</code> Raw transaction bytes <code>interpreter.wasm</code> WASM module that parses the payload into human-readable JSON <code>sign.cbor</code> Signing specification: algorithm, key ID, what bytes to sign"},{"location":"architecture/usb-protocol/#preparing-a-usb-stick","title":"Preparing a USB stick","text":"<p>Use the <code>usb-pack</code> CLI:</p> <pre><code>usb-pack \\\n  --payload tx.raw \\\n  --interpreter cardano-cbor.wasm \\\n  --output /mnt/usb \\\n  --label \"Cardano Transaction\" \\\n  --algorithm ed25519 \\\n  --key-id payment-0 \\\n  --signable hash-blake2b \\\n  --output-mode wasm-assemble\n</code></pre>"},{"location":"architecture/usb-protocol/#mount-protocol","title":"Mount protocol","text":"<ol> <li>Device detects USB insertion via udev/poll</li> <li>Mounts the first VFAT partition read-only</li> <li>Reads the three files into memory</li> <li>Unmounts before processing (minimizes USB exposure)</li> <li>After signing, remounts read-write to write <code>signed.bin</code></li> <li>Unmounts and signals completion</li> </ol> <p>During signing, the device only reads these three files \u2014 nothing else.</p>"},{"location":"architecture/usb-protocol/#setup-usb-protocol","title":"Setup USB protocol","text":"<p>During first-time provisioning, the device uses two separate USB sticks:</p>"},{"location":"architecture/usb-protocol/#private-usb-seed-backup","title":"Private USB (seed backup)","text":"File Purpose <code>seed.bin</code> 32-byte Ed25519 seed (raw bytes) <ul> <li>If <code>seed.bin</code> exists when inserted, the device recovers the key from it (import).</li> <li>If <code>seed.bin</code> does not exist, the device generates a new key and writes <code>seed.bin</code>.</li> <li>Store this USB offline in a safe place. It is the only way to recover funds if the device is lost or stolen.</li> </ul>"},{"location":"architecture/usb-protocol/#public-usb-key-export","title":"Public USB (key export)","text":"File Purpose <code>pubkey.bin</code> 32-byte Ed25519 public key (raw bytes) <ul> <li>Written during setup after key generation/recovery.</li> <li>Used to register the public key on-chain.</li> </ul>"},{"location":"architecture/wasm-sandbox/","title":"WASM Sandbox","text":"<p>Interpreters run inside a Wasmtime sandbox with strict resource limits.</p>"},{"location":"architecture/wasm-sandbox/#security-properties","title":"Security properties","text":"<ul> <li>Zero imports \u2014 the WASM module cannot call any host functions.   No filesystem, no network, no clock, no randomness.</li> <li>Fuel-metered \u2014 10 million operations budget. Prevents infinite loops   and excessive computation.</li> <li>Memory-capped \u2014 16 MB maximum linear memory. Prevents OOM on the device.</li> <li>Stack-limited \u2014 512 KiB call stack.</li> </ul>"},{"location":"architecture/wasm-sandbox/#abi-contract","title":"ABI contract","text":"<p>The WASM module must export:</p>"},{"location":"architecture/wasm-sandbox/#memory","title":"<code>memory</code>","text":"<p>The module's linear memory, accessible to the host for data transfer.</p>"},{"location":"architecture/wasm-sandbox/#allocsize-i32-i32","title":"<code>alloc(size: i32) -&gt; i32</code>","text":"<p>Allocate <code>size</code> bytes in WASM memory. Returns a pointer (offset into linear memory), or 0 on failure.</p>"},{"location":"architecture/wasm-sandbox/#interpretptr-i32-len-i32-i32","title":"<code>interpret(ptr: i32, len: i32) -&gt; i32</code>","text":"<p>Parse the payload bytes at <code>[ptr, ptr+len)</code> and return a pointer to a length-prefixed UTF-8 JSON string:</p> <pre><code>[4 bytes LE u32: length][length bytes: UTF-8 JSON]\n</code></pre>"},{"location":"architecture/wasm-sandbox/#assemblepayload_ptr-i32-payload_len-i32-sig_ptr-i32-sig_len-i32-i32","title":"<code>assemble(payload_ptr: i32, payload_len: i32, sig_ptr: i32, sig_len: i32) -&gt; i32</code>","text":"<p>(Optional) Combine the original payload and signature into a final signed artifact. Same length-prefixed output convention.</p>"},{"location":"architecture/wasm-sandbox/#why-wasm","title":"Why WASM","text":"<ul> <li>Polyglot \u2014 interpreters can be written in Rust, C, AssemblyScript, or any language targeting wasm32</li> <li>Deterministic \u2014 same input always produces same output (no I/O, no randomness)</li> <li>Small \u2014 the echo-hex interpreter compiles to ~1 KB</li> <li>Auditable \u2014 <code>wasm2wat</code> produces readable text format for review</li> </ul>"},{"location":"dev/getting-started/","title":"Getting Started","text":""},{"location":"dev/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Nix with flakes enabled</li> </ul>"},{"location":"dev/getting-started/#setup","title":"Setup","text":"<pre><code>git clone https://github.com/paolino/air-gap-signer.git\ncd air-gap-signer\nnix develop\n</code></pre> <p>The nix shell provides Rust (with <code>wasm32-unknown-unknown</code> target), <code>just</code>, <code>wasmtime</code>, and <code>mkdocs</code>.</p>"},{"location":"dev/getting-started/#build","title":"Build","text":"<pre><code>just build       # Build all host crates\njust build-wasm  # Build WASM interpreters\n</code></pre>"},{"location":"dev/getting-started/#test","title":"Test","text":"<pre><code>just test        # Run all tests (builds WASM first)\n</code></pre>"},{"location":"dev/getting-started/#desktop-simulator","title":"Desktop simulator","text":"<pre><code>just sim         # Run simulator (creates keys.json on first run)\n</code></pre> <p>First run triggers the setup flow:</p> <ol> <li>SET PIN \u2014 enter 4-digit PIN with Up/Down + Enter</li> <li>CONFIRM PIN \u2014 re-enter to confirm</li> <li>INSERT PRIVATE USB \u2014 if <code>seed.bin</code> exists in the USB directory, the key is recovered; otherwise a new key is generated and <code>seed.bin</code> is written</li> <li>INSERT PUBLIC USB \u2014 <code>pubkey.bin</code> is written for on-chain registration</li> <li>SETUP COMPLETE \u2014 device enters the signing loop</li> </ol> <p>Subsequent runs skip setup and prompt for PIN entry directly.</p>"},{"location":"dev/getting-started/#full-ci-locally","title":"Full CI locally","text":"<pre><code>just ci          # format-check, lint, build, build-wasm, test\n</code></pre>"},{"location":"dev/getting-started/#documentation","title":"Documentation","text":"<pre><code>just serve-docs  # Local preview at http://127.0.0.1:8000\njust build-docs  # Build static site\n</code></pre>"},{"location":"dev/getting-started/#project-layout","title":"Project layout","text":"<pre><code>crates/\n  signer-core/     # Pure logic (spec, WASM sandbox, crypto, display)\n  signer-hal/      # Hardware abstraction traits\n  signer-sim/      # Desktop simulator with simulated SE\n  usb-pack/        # CLI to prepare USB sticks\n\ninterpreters/\n  echo-hex/        # Test interpreter (hex dump)\n\nbuildroot/         # Minimal Linux image (Phase 5)\n</code></pre>"},{"location":"dev/phases/","title":"Development Phases","text":""},{"location":"dev/phases/#phase-0-foundation-material-check","title":"Phase 0: Foundation :material-check:","text":"<ul> <li> Cargo workspace + flake.nix + justfile</li> <li> <code>signer-core/spec.rs</code> \u2014 SigningSpec CBOR types</li> <li> <code>signer-core/wasm_sandbox.rs</code> \u2014 Wasmtime with fuel/memory limits</li> <li> <code>signer-core/crypto.rs</code> \u2014 Ed25519 signing + hash dispatch</li> <li> <code>signer-core/display.rs</code> \u2014 JSON to display lines</li> <li> <code>signer-hal</code> \u2014 Hardware abstraction traits</li> <li> <code>echo-hex</code> WASM interpreter</li> <li> 17 tests passing</li> </ul>"},{"location":"dev/phases/#phase-1-desktop-simulator","title":"Phase 1: Desktop Simulator","text":"<ul> <li> <code>signer-sim</code> with minifb window + keyboard input</li> <li> JSON rendering on simulated screen</li> <li> End-to-end signing flow in simulator</li> <li> Interactive setup flow: PIN entry, key generation/recovery, dual-USB export</li> <li> Simulated secure element with PIN hash, session state, save/load to JSON</li> <li> <code>usb-pack</code> CLI for preparing test USB contents</li> </ul>"},{"location":"dev/phases/#phase-2-cardano-interpreter","title":"Phase 2: Cardano Interpreter","text":"<ul> <li> <code>interpreters/cardano-cbor</code> \u2014 parse Cardano TX CBOR to JSON</li> <li> WASM <code>assemble()</code> \u2014 attach witness to transaction</li> <li> <code>HashThenSign</code> with Blake2b-256</li> <li> Test with real Cardano testnet transactions</li> </ul>"},{"location":"dev/phases/#phase-3-secure-element-integration","title":"Phase 3: Secure Element Integration","text":"<ul> <li> SE050 driver over I2C (HAL <code>SecureElement</code> trait)</li> <li> Key generation inside SE (private key never exported)</li> <li> PIN verification with hardware retry lockout</li> <li> Public key export via USB (for on-chain registration)</li> <li> SE-side signing: Pi sends hash, SE returns signature</li> <li> PIN entry UI (buttons + display)</li> <li> Simulator mock SE (in-memory keys for desktop testing)</li> <li> Seed backup to private USB + recovery from existing seed</li> </ul>"},{"location":"dev/phases/#phase-4-raspberry-pi-hal","title":"Phase 4: Raspberry Pi HAL","text":"<ul> <li> <code>signer-pi</code> \u2014 framebuffer, GPIO buttons, USB mount, I2C secure element</li> <li> Cross-compile aarch64-unknown-linux-musl</li> <li> Test on physical Pi 4 or Pi Zero 2W with display + buttons + SE050</li> </ul>"},{"location":"dev/phases/#phase-5-buildroot-image","title":"Phase 5: Buildroot Image","text":"<ul> <li> External tree, kernel config, defconfig</li> <li> <code>just image</code> recipe</li> <li> Boot time optimization (target: &lt;3s to PIN prompt)</li> </ul>"},{"location":"dev/phases/#phase-6-hardening","title":"Phase 6: Hardening","text":"<ul> <li> Security audit</li> <li> Secp256k1 ECDSA + Schnorr support</li> <li> Read-only rootfs (squashfs)</li> <li> Multiple key slots (up to 16 per SE)</li> <li> Key slot labelling (associate slot with blockchain/purpose)</li> </ul>"}]}